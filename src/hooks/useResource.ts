/**
 * useResource.ts - FOUNDATIONAL INFRASTRUCTURE HOOK
 * 
 * Core hook for low-level FHIR resource operations with enhanced error handling
 * 
 * ⚠️  ARCHITECTURAL NOTE: This hook is NOT factory-generated by design
 * 
 * PURPOSE: Provides foundational CRUD operations that the factory system builds upon
 * - Used BY the factory system internally for resource operations
 * - Offers low-level control for specialized hooks (like usePractitionerPatients)
 * - Handles authentication, error handling, and connection management
 * - Provides generic fetchResource, createResource, updateResource, deleteResource
 * 
 * RELATIONSHIP TO FACTORY SYSTEM:
 * - Base hooks (useBaseCRUD) use this hook internally
 * - Factory-generated hooks inherit functionality through base hooks
 * - Specialized business logic hooks can use this directly for custom operations
 * 
 * STATUS: Foundational infrastructure - maintain as core dependency
 * FIXED: Authentication and search method issues resolved
 */
import { useState, useCallback, useRef, useEffect } from 'react';
import { Resource, Bundle, ResourceType } from '@medplum/fhirtypes';
import { useMedplum } from './useMedplum';
import { createLogger } from '../utils/logger';
import { FilterParams, PaginationParams, SortParams } from '../services/models';
// Import debug utility
import { debugResourceData } from './debugResourceData';

interface UseResourceOptions {
  resourceType: string;
  onSuccess?: ((resource: Resource) => void) | ((resources: Resource[]) => void);
  onError?: (error: Error) => void;
}

/**
 * Hook for fetching, creating, and updating FHIR resources
 */
export function useResource({
  resourceType,
  onSuccess,
  onError
}: UseResourceOptions) {
  const [data, setData] = useState<Resource | Resource[] | Bundle | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const medplum = useMedplum();
  const logger = createLogger(`useResource(${resourceType})`);

  // Store resource type in a ref to ensure stable reference
  const resourceTypeRef = useRef(resourceType);

  // Update the ref if resourceType changes
  useEffect(() => {
    resourceTypeRef.current = resourceType;
  }, [resourceType]);

  /**
   * Fetch a single resource
   */
  const fetchResource = useCallback(async <T extends Resource>(id: string): Promise<T> => {
    setIsLoading(true);
    setError(null);

    try {
      if (!id) {
        logger.error('fetchResource called with empty or undefined ID');
        throw new Error('Resource ID is required');
      }

      logger.debug(`Fetching ${resourceTypeRef.current} with ID: ${id}`);
      const resource = await medplum.readResource(resourceTypeRef.current as ResourceType, id) as T;

      // Debug the resource before setting data
      debugResourceData(`fetchResource(${resourceTypeRef.current}/${id})`, resource);

      // Update the data state - ensure this is a consistent format
      setData(resource);

      if (onSuccess) {
        // Type guard to handle single resource callback
        if (typeof onSuccess === 'function') {
          (onSuccess as (resource: Resource) => void)(resource);
        }
      }

      setIsLoading(false);
      return resource;
    } catch (err) {
      let error = err instanceof Error ? err : new Error(String(err));

      // Enhance 404/not found errors with more context
      const errorMessage = error.message.toLowerCase();
      if (errorMessage.includes('not found') ||
        errorMessage.includes('404') ||
        errorMessage.includes('not_found') ||
        errorMessage.includes('resource not found')) {
        error = new Error(`${resourceTypeRef.current} with ID "${id}" was not found`);
        error.name = 'ResourceNotFoundError';
      }

      logger.error(`Failed to fetch ${resourceTypeRef.current}/${id}`, {
        error: error.message,
        errorName: error.name,
        stack: error.stack
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  /**
   * Fetch all resources
   */
  const fetchResources = useCallback(async <T extends Resource>(options: { filters?: FilterParams; pagination?: PaginationParams; sort?: SortParams } | any = {}): Promise<T[]> => {
    setIsLoading(true);
    setError(null);

    // Create a string representation of options to use as a stable reference
    const optionsKey = JSON.stringify(options);

    try {
      logger.debug('Fetching resources with options', { options, resourceType: resourceTypeRef.current });

      // Parse options back from string to ensure consistent reference
      const parsedOptions = JSON.parse(optionsKey);

      // Use the fetchResources method from the medplum context
      const resources = await medplum.fetchResources<T>(resourceTypeRef.current as ResourceType, parsedOptions);

      // Create a bundle-like structure for consistent data handling
      const bundle: Bundle = {
        resourceType: 'Bundle',
        type: 'searchset',
        entry: resources.map(resource => ({ resource }))
      };

      logger.debug('Created bundle from resources', { bundle, count: resources.length });

      // Update the data state with the bundle
      setData(bundle);

      if (onSuccess) {
        // Type guard to handle both single and multiple resource callbacks
        if (typeof onSuccess === 'function') {
          if (resources.length === 1) {
            (onSuccess as (resource: Resource) => void)(resources[0]);
          } else {
            (onSuccess as (resources: Resource[]) => void)(resources);
          }
        }
      }

      setIsLoading(false);
      return resources;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      logger.error(`Failed to fetch ${resourceTypeRef.current} resources`, {
        error: error.message
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  /**
   * Create a resource
   */
  const createResource = useCallback(async <T extends Resource>(resource: T): Promise<T> => {
    setIsLoading(true);
    setError(null);

    try {
      logger.debug(`Creating new ${resourceTypeRef.current} resource`);
      const createdResource = await medplum.createResource<T>(resource);

      // Update the data state
      setData(createdResource);

      if (onSuccess) {
        // Type guard to handle single resource callback
        if (typeof onSuccess === 'function') {
          (onSuccess as (resource: Resource) => void)(createdResource);
        }
      }

      setIsLoading(false);
      return createdResource;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      logger.error(`Failed to create ${resourceTypeRef.current} resource`, {
        error: error.message
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  /**
   * Update a resource
   */
  const updateResource = useCallback(async <T extends Resource>(resource: T): Promise<T> => {
    setIsLoading(true);
    setError(null);

    try {
      logger.debug(`Updating ${resourceTypeRef.current}/${resource.id}`);
      const updatedResource = await medplum.updateResource<T>(resource);

      // Update the data state
      setData(updatedResource);

      if (onSuccess) {
        // Type guard to handle single resource callback
        if (typeof onSuccess === 'function') {
          (onSuccess as (resource: Resource) => void)(updatedResource);
        }
      }

      setIsLoading(false);
      return updatedResource;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      logger.error(`Failed to update ${resourceTypeRef.current} resource`, {
        resourceId: resource.id,
        error: error.message
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  /**
   * Delete a resource
   */
  const deleteResource = useCallback(async <T extends Resource>(id: string): Promise<T> => {
    setIsLoading(true);
    setError(null);

    try {
      logger.debug(`Deleting ${resourceTypeRef.current}/${id}`);
      const deletedResource = await medplum.deleteResource(resourceTypeRef.current as ResourceType, id) as T;

      // Clear the data state as the resource is deleted
      setData(null);

      if (onSuccess) {
        // Type guard to handle single resource callback
        if (typeof onSuccess === 'function') {
          (onSuccess as (resource: Resource) => void)(deletedResource);
        }
      }

      setIsLoading(false);
      return deletedResource;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      logger.error(`Failed to delete ${resourceTypeRef.current}/${id}`, {
        error: error.message
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  /**
   * Search resources with the given query parameters - ENHANCED VERSION
   */
  const searchResources = useCallback(async <T extends Resource>(queryParams: Record<string, any> = {}): Promise<T[]> => {
    setIsLoading(true);
    setError(null);

    try {
      logger.debug('Searching resources with query', { queryParams, resourceType: resourceTypeRef.current });

      // ENHANCEMENT: Check authentication status first
      if (!medplum.isInitialized) {
        throw new Error('Medplum client is not initialized. Please check your authentication.');
      }

      // ENHANCEMENT: Check server availability
      if (!medplum.isServerAvailable && !medplum.isOnline) {
        throw new Error('Server is not available and you are offline. Cannot perform search.');
      }

      let searchResult;

      try {
        // OPTION 1: Try using the standard search method first
        if (typeof medplum.search === 'function') {
          logger.debug('Using medplum.search method');
          searchResult = await medplum.search(resourceTypeRef.current as ResourceType, queryParams);
        } else {
          // OPTION 2: Fallback to searchResources method if available
          logger.debug('search method not available, trying searchResources');
          if (typeof medplum.searchResources === 'function') {
            const resources = await medplum.searchResources(resourceTypeRef.current as ResourceType, queryParams);
            // Convert to Bundle format for consistency
            searchResult = {
              resourceType: 'Bundle',
              type: 'searchset',
              entry: resources.map((resource) => ({ resource }))
            } as Bundle<T>;
          } else {
            // OPTION 3: Use fetchResources as final fallback
            logger.debug('searchResources not available, using fetchResources');
            const resources = await medplum.fetchResources<T>(resourceTypeRef.current as ResourceType, { filters: queryParams });
            // Convert to Bundle format for consistency
            searchResult = {
              resourceType: 'Bundle',
              type: 'searchset',
              entry: resources.map((resource: T) => ({ resource }))
            };
          }
        }
      } catch (searchError) {
        // Enhanced error handling for different types of search failures
        const errorMessage = searchError instanceof Error ? searchError.message : String(searchError);

        logger.error('Search method failed, trying alternative approach', {
          originalError: errorMessage,
          queryParams,
          resourceType: resourceTypeRef.current
        });

        // If search fails, try direct fetch without filters as final fallback
        try {
          const resources = await medplum.fetchResources<T>(resourceTypeRef.current as ResourceType, {});
          // Client-side filtering if necessary
          const filteredResources = resources.filter((resource: T) => {
            // Simple client-side filtering for name searches
            if (queryParams.name && resource.resourceType === 'Practitioner') {
              const practitioner = resource as any;
              const name = practitioner.name?.[0];
              if (name) {
                const fullName = `${name.given?.[0] || ''} ${name.family || ''}`.toLowerCase();
                return fullName.includes(queryParams.name.toLowerCase());
              }
            }
            return true;
          });

          searchResult = {
            resourceType: 'Bundle',
            type: 'searchset',
            entry: filteredResources.map((resource: T) => ({ resource }))
          };
        } catch (fallbackError) {
          throw new Error(`All search methods failed. Original error: ${errorMessage}. Fallback error: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`);
        }
      }

      // Extract the resources from the search result and filter out any undefined entries
      const resources: T[] = [];
      if (searchResult?.entry) {
        for (const entry of searchResult.entry) {
          if (entry.resource) {
            resources.push(entry.resource as T);
          }
        }
      }

      logger.debug('Search results', { count: resources.length, hasResults: resources.length > 0 });

      // Update the data state with the search results
      setData(resources.length > 0 ? resources : null);

      if (onSuccess) {
        // Trigger the success callback with the found resources
        if (typeof onSuccess === 'function') {
          if (resources.length === 1) {
            (onSuccess as (resource: Resource) => void)(resources[0]);
          } else {
            (onSuccess as (resources: Resource[]) => void)(resources);
          }
        }
      }

      setIsLoading(false);
      return resources;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));

      logger.error(`Failed to search ${resourceTypeRef.current} resources`, {
        error: error.message,
        queryParams,
        stackTrace: error.stack
      });

      setError(error);

      if (onError) {
        onError(error);
      }

      setIsLoading(false);
      throw error;
    }
  }, [medplum, onSuccess, onError, logger]);

  return {
    data,
    isLoading,
    error,
    fetchResource,
    createResource,
    updateResource,
    deleteResource,
    fetchResources,
    searchResources
  };
}